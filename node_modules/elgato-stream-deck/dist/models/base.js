"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDeckBase = void 0;
const events_1 = require("events");
const exitHook = require("exit-hook");
const HID = require("node-hid");
const util_1 = require("../util");
class StreamDeckBase extends events_1.EventEmitter {
    constructor(deviceInfo, options, properties) {
        super();
        this.deviceProperties = properties;
        this.options = options;
        this.device = new HID.HID(deviceInfo.path);
        this.releaseExitHook = exitHook(() => {
            try {
                this.close();
            }
            catch (e) {
                // Ignore errors, as device is already closed
            }
        });
        this.keyState = new Array(this.NUM_KEYS).fill(false);
        this.device.on('data', (data) => {
            // The first byte is a report ID, the last byte appears to be padding.
            // We strip these out for now.
            data = data.slice(this.deviceProperties.KEY_DATA_OFFSET, data.length - 1);
            for (let i = 0; i < this.NUM_KEYS; i++) {
                const keyPressed = Boolean(data[i]);
                const keyIndex = this.transformKeyIndex(i);
                const stateChanged = keyPressed !== this.keyState[keyIndex];
                if (stateChanged) {
                    this.keyState[keyIndex] = keyPressed;
                    if (keyPressed) {
                        this.emit('down', keyIndex);
                    }
                    else {
                        this.emit('up', keyIndex);
                    }
                }
            }
        });
        this.device.on('error', (err) => {
            this.emit('error', err);
        });
    }
    get NUM_KEYS() {
        return this.KEY_COLUMNS * this.KEY_ROWS;
    }
    get KEY_COLUMNS() {
        return this.deviceProperties.COLUMNS;
    }
    get KEY_ROWS() {
        return this.deviceProperties.ROWS;
    }
    get ICON_SIZE() {
        return this.deviceProperties.ICON_SIZE;
    }
    get ICON_BYTES() {
        return this.ICON_PIXELS * 3;
    }
    get ICON_PIXELS() {
        return this.ICON_SIZE * this.ICON_SIZE;
    }
    get MODEL() {
        return this.deviceProperties.MODEL;
    }
    fillColor(keyIndex, r, g, b) {
        this.checkValidKeyIndex(keyIndex);
        this.checkRGBValue(r);
        this.checkRGBValue(g);
        this.checkRGBValue(b);
        const pixels = Buffer.alloc(this.ICON_BYTES, Buffer.from([r, g, b]));
        const keyIndex2 = this.transformKeyIndex(keyIndex);
        // TODO - this could be cleverer and skip all the transform logic, but I dont expect it to be used enough to justify that
        this.fillImageRange(keyIndex2, pixels, {
            format: 'rgb',
            offset: 0,
            stride: this.ICON_SIZE * 3,
        });
    }
    fillImage(keyIndex, imageBuffer, options) {
        var _a;
        this.checkValidKeyIndex(keyIndex);
        const sourceFormat = (_a = options === null || options === void 0 ? void 0 : options.format) !== null && _a !== void 0 ? _a : 'rgb';
        this.checkSourceFormat(sourceFormat);
        const imageSize = this.ICON_PIXELS * sourceFormat.length;
        if (imageBuffer.length !== imageSize) {
            throw new RangeError(`Expected image buffer of length ${imageSize}, got length ${imageBuffer.length}`);
        }
        const keyIndex2 = this.transformKeyIndex(keyIndex);
        this.fillImageRange(keyIndex2, imageBuffer, {
            format: sourceFormat,
            offset: 0,
            stride: this.ICON_SIZE * sourceFormat.length,
        });
    }
    fillPanel(imageBuffer, options) {
        var _a;
        const sourceFormat = (_a = options === null || options === void 0 ? void 0 : options.format) !== null && _a !== void 0 ? _a : 'rgb';
        this.checkSourceFormat(sourceFormat);
        const imageSize = this.ICON_PIXELS * sourceFormat.length * this.NUM_KEYS;
        if (imageBuffer.length !== imageSize) {
            throw new RangeError(`Expected image buffer of length ${imageSize}, got length ${imageBuffer.length}`);
        }
        const iconSize = this.ICON_SIZE * sourceFormat.length;
        const stride = iconSize * this.KEY_COLUMNS;
        for (let row = 0; row < this.KEY_ROWS; row++) {
            const rowOffset = stride * row * this.ICON_SIZE;
            for (let column = 0; column < this.KEY_COLUMNS; column++) {
                let index = row * this.KEY_COLUMNS;
                if (this.deviceProperties.KEY_DIRECTION === 'ltr') {
                    index += column;
                }
                else {
                    index += this.KEY_COLUMNS - column - 1;
                }
                const colOffset = column * iconSize;
                this.fillImageRange(index, imageBuffer, {
                    format: sourceFormat,
                    offset: rowOffset + colOffset,
                    stride,
                });
            }
        }
    }
    clearKey(keyIndex) {
        this.checkValidKeyIndex(keyIndex);
        return this.fillColor(keyIndex, 0, 0, 0);
    }
    clearAllKeys() {
        // TODO - this could be restructured to be more efficient (by reusing the final colour buffer)
        for (let keyIndex = 0; keyIndex < this.NUM_KEYS; keyIndex++) {
            this.clearKey(keyIndex);
        }
    }
    setBrightness(percentage) {
        if (percentage < 0 || percentage > 100) {
            throw new RangeError('Expected brightness percentage to be between 0 and 100');
        }
        // prettier-ignore
        const brightnessCommandBuffer = Buffer.from([
            0x05, 0x55, 0xaa, 0xd1, 0x01, percentage, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00
        ]);
        this.device.sendFeatureReport(brightnessCommandBuffer);
    }
    resetToLogo() {
        // prettier-ignore
        const resetCommandBuffer = Buffer.from([
            0x0B, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00
        ]);
        this.device.sendFeatureReport(resetCommandBuffer);
    }
    getFirmwareVersion() {
        return util_1.numberArrayToString(this.device.getFeatureReport(4, 17).slice(5));
    }
    getSerialNumber() {
        return util_1.numberArrayToString(this.device.getFeatureReport(3, 17).slice(5, 17));
    }
    close() {
        this.releaseExitHook();
        if (this.options.resetToLogoOnExit) {
            // This makes the reset happen much quicker than the default timeout
            this.resetToLogo();
        }
        this.device.close();
    }
    getFillImageCommandHeaderLength() {
        return 16;
    }
    writeFillImageCommandHeader(buffer, keyIndex, partIndex, isLast, _bodyLength) {
        buffer.writeUInt8(0x02, 0);
        buffer.writeUInt8(0x01, 1);
        buffer.writeUInt16LE(partIndex, 2);
        // 3 = 0x00
        buffer.writeUInt8(isLast ? 1 : 0, 4);
        buffer.writeUInt8(keyIndex + 1, 5);
    }
    generateFillImageWrites(keyIndex, byteBuffer) {
        const MAX_PACKET_SIZE = this.getFillImagePacketLength();
        const PACKET_HEADER_LENGTH = this.getFillImageCommandHeaderLength();
        const MAX_PAYLOAD_SIZE = MAX_PACKET_SIZE - PACKET_HEADER_LENGTH;
        const result = [];
        let remainingBytes = byteBuffer.length;
        for (let part = 0; remainingBytes > 0; part++) {
            const packet = Buffer.alloc(MAX_PACKET_SIZE);
            const byteCount = Math.min(remainingBytes, MAX_PAYLOAD_SIZE);
            this.writeFillImageCommandHeader(packet, keyIndex, part, remainingBytes <= MAX_PAYLOAD_SIZE, byteCount);
            const byteOffset = byteBuffer.length - remainingBytes;
            remainingBytes -= byteCount;
            byteBuffer.copy(packet, PACKET_HEADER_LENGTH, byteOffset, byteOffset + byteCount);
            result.push(packet);
        }
        return result;
    }
    sendFeatureReport(payload) {
        return this.device.sendFeatureReport(payload);
    }
    getFeatureReport(reportId, reportLength) {
        return this.device.getFeatureReport(reportId, reportLength);
    }
    fillImageRange(keyIndex, imageBuffer, sourceOptions) {
        this.checkValidKeyIndex(keyIndex);
        const byteBuffer = this.convertFillImage(imageBuffer, sourceOptions);
        const packets = this.generateFillImageWrites(keyIndex, byteBuffer);
        for (const packet of packets) {
            this.device.write(packet);
        }
    }
    checkValidKeyIndex(keyIndex) {
        if (keyIndex < 0 || keyIndex >= this.NUM_KEYS) {
            throw new TypeError(`Expected a valid keyIndex 0 - ${this.NUM_KEYS - 1}`);
        }
    }
    checkRGBValue(value) {
        if (value < 0 || value > 255) {
            throw new TypeError('Expected a valid color RGB value 0 - 255');
        }
    }
    checkSourceFormat(format) {
        switch (format) {
            case 'rgb':
            case 'rgba':
            case 'bgr':
            case 'bgra':
                break;
            default: {
                const fmt = format;
                throw new TypeError(`Expected a known color format not "${fmt}"`);
            }
        }
    }
}
exports.StreamDeckBase = StreamDeckBase;
//# sourceMappingURL=base.js.map